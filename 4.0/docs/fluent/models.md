# Models

Models represent data stored in tables or collections in your database. Models have one or more fields that store codable values. All models have a unique identifier. Property wrappers are used to denote identifiers, fields, and relations. 

Below is an example of a simple model with one field. Note that models do not describe the entire database schema, such as constraints, indexes, and foreign keys. Schemas are defined in [migrations](migrations.md). Models are focused on handling the data stored in your database schemas.  

```swift
final class Galaxy: Model {
    // Name of the table or collection.
    static let schema = "galaxies"

    // Unique identifier for this Galaxy.
    @ID(key: .id)
    var id: UUID?

    // The Galaxy's name.
    @Field(key: "name")
    var name: String

    // Creates a new, empty Galaxy.
    init() { }

    // Creates a new Galaxy with all properties set.
    init(id: UUID? = nil, name: String) {
        self.id = id
        self.name = name
    }
}
```

## Schema

All models require a static, get-only `schema` property. This string references the table or collection this model represents. 

```swift
final class Galaxy: Model {
    // Name of the table or collection.
    static let schema = "galaxies"
}
```

When querying this model, data will be fetched from and stored to the schema named `"galaxies"`.

!!! tip
    The schema name is typically the class name pluralized and lowercased. 

## Identifier

All models must have an `id` property defined using the `@ID` property wrapper. This field uniquely identifies instances of your model.

```swift
final class Galaxy: Model {
    // Unique identifier for this Galaxy.
    @ID(key: .id)
    var id: UUID?
}
```

By default, the `@ID` property should use the special `.id` key which resolves to an appropriate key for the underlying database driver. For SQL this is `"id"` and for NoSQL it is `"_id"`. 

The `@ID` should also be of type `UUID`. This is the only identifier value currently supported by all database drivers. Fluent will automatically generate new UUID identifiers when models are created. 

`@ID` has an optional value since unsaved models may not yet have an identifier. To get the identifier or throw an error, use `requireID`.

```swift
let id = try planet.requireID()
```

### Exists

`@ID` has an `exists` property that represents whether the model exists in the database or not. When you initialize a model, the value is `false`. After you save a model or when you fetch a model from the database, the value is `true`. This property is mutable.

```swift
print(planet.$id.exists)
```

### Custom Identifier

Fluent supports custom identifier keys and types using the `@ID(custom:)` overload. 

```swift
final class Galaxy: Model {
    // Unique identifier for this Galaxy.
    @ID(custom: "foo")
    var id: Int?
}
```

The above example uses an `@ID` with custom key `"foo"` and identifier type `Int`. This is compatible with SQL databases using auto-incrementing primary keys, but is not compatible with NoSQL. 

Custom `@ID`s allow the user to specify how the identifier should be generated using the `generatedBy` parameter.

```swift
@ID(custom: "foo", generatedBy: .user)
```

There are three cases:

|Generated By|Description|
|-|-|
|`.user`|`@ID` property is expected to be set before saving a new model.|
|`.random`|`@ID` value type must conform to `RandomGeneratable`.|
|`.database`|Database is expected to generate a value upon save.|

If the `generatedBy` parameter is omitted, Fluent will attempt to infer an appropriate case based on the `@ID` value type. For example, `Int` will default to `.database` generation unless otherwise specified.

## Initializer

Models must have an empty initializer method.

```swift
final class Galaxy: Model {
    // Creates a new, empty Galaxy.
    init() { }
}
```

Fluent requires this method internally to initialize models returned by queries. It is also used for reflection. 

You may also want to add a convenience initializer to your model that accepts all properties. 

```swift
final class Galaxy: Model {
    // Creates a new Galaxy with all properties set.
    init(id: UUID? = nil, name: String) {
        self.id = id
        self.name = name
    }
}
```

Using convenience initializers makes it easier to add new properties to the model in the future. 

## Field

Models can have zero or more `@Field` properties for storing data. 

```swift
final class Galaxy: Model {
    // The Galaxy's name.
    @Field(key: "name")
    var name: String
}
```

Fields require the database key to be explicitly defined. This is not required to be the same as the property name. 

!!! tip
    Fluent recommends using `snake_case` for database keys and `camelCase` for property names. 

Field values can be any type that conforms to `Codable`. Storing nested structures and arrays in `@Field` is supported, but filtering operations are limited. See [`@Group`](#group) for more robust nesting.

For fields that contain an optional value, use `@OptionalField`. 

```swift
@OptionalField(key: "tag")
var tag: String?
```

## Relations

Models can have zero or more relation properties referencing other models like `@Parent`, `@Children`, and `@Siblings`. Learn more about relations in the [Relations](relations.md) section.

## Timestamp

`@Timestamp` is a special type of `@Field` that stores a `Foundation.Date`. Timestamps are set automatically by Fluent according to the chosen trigger.

```swift
final class Galaxy: Model {
    // When this Galaxy was created.
    @Timestamp(key: "created_at", on: .create)
    var createdAt: Date?

    // When this Galaxy was last updated.
    @Timestamp(key: "updated_at", on: .update)
    var updatedAt: Date?
}
```

The timestamp values are optional and should be set to `nil` when initializing a new model. 

|Trigger|Description|
|-|-|
|`.create`|Set when a new model instance is saved to the database.|
|`.update`|Set when an existing model instance is saved to the database.|
|`.delete`|Set when a model is deleted from the database. See [soft delete](#soft-delete).|

### Timestamp Format

By default, `@Timestamp` will use an efficient datetime encoding based on your database driver. You can customize how the timestamp is stored in the database using the `format` parameter.

```swift
// Stores an ISO 8601 formatted timestamp representing
// when this model was last updated.
@Timestamp(key: "updated_at", on: .update, format: .iso8601)
var updatedAt: Date?
```

Available timestamp formats are listed below.

|Format|Description|Type|
|-|-|-|
|`.default`|Uses efficient datetime encoding for specific database.|Date|
|`.iso8601`|[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string. Supports `withMilliseconds` parameter.|String|
|`.unix`|Seconds since Unix epoch including fraction.|Double|

You can access the raw timestamp value directly using the `timestamp` property.

```swift
// Manually set the timestamp value on this ISO 8601
// formatted @Timestamp.
model.$updatedAt.timestamp = "2020-06-03T16:20:14+00:00"
```

### Soft Delete

Adding a `@Timestamp` that uses the `.delete` trigger to your model will enable soft-deletion.

```swift
final class Galaxy: Model {
    // When this Galaxy was deleted.
    @Timestamp(key: "deleted_at", on: .delete)
    var deletedAt: Date?
}
```

Soft-deleted models still exist in the database after deletion, but will not be returned in queries. 

!!! tip
    You can manually set an on delete timestamp to a date in the future. This can be used as an expiration date.

To force a soft-deletable model to be removed from the database, use the `force` parameter in `delete`. 

```swift
// Deletes from the database even if the model 
// is soft deletable. 
model.delete(force: true, on: database)
```

To restore a soft-deleted model, use the `restore` method.

```swift
// Clears the on delete timestamp allowing this 
// model to be returned in queries. 
model.restore(on: database)
```

To include soft-deleted models in a query, use `withDeleted`. 

```swift
// Fetches all galaxies including soft deleted.
Galaxy.query(on: database).withDeleted().all()
```

## Enum

TODO: @Enum, @OptionalEnum

## Group

TODO: @Group

## Codable

TODO: Codable conformance, DTOs

## Alias

TODO: ModelAlias

## CRUD

TODO: Create, Read, Update, Delete

TODO: hasChanges

## Query

Models expose a static method `query(on:)` that returns a query builder. 

```swift
Planet.query(on: database).all()
```

Learn more about querying in the [Query Builder](./query-builder.md) section.

## Find

Models have a static `find(_:on:)` method for looking up a model instance by identifier. 

```swift
Planet.find(req.parameters.get("id"), on: database)
```

This method returns `nil` if no model with that identifier was found.
