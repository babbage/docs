# Models

Models represent data stored in tables or collections in your database. Models have one or more fields that store codable values. All models have a unique identifier. Property wrappers are used to denote identifiers, fields, and relations. 

Below is an example of a simple model with one field. Note that models do not describe the entire database schema, such as constraints, indexes, and foreign keys. Schemas are defined in [migrations](migrations.md). Models are focused on handling the data stored in your database schemas.  

```swift
final class Galaxy: Model {
    // Name of the table or collection.
    static let schema = "galaxies"

    // Unique identifier for this Galaxy.
    @ID(key: .id)
    var id: UUID?

    // The Galaxy's name.
    @Field(key: "name")
    var name: String

    // Creates a new, empty Galaxy.
    init() { }

    // Creates a new Galaxy with all properties set.
    init(id: UUID? = nil, name: String) {
        self.id = id
        self.name = name
    }
}
```

## Schema

All models require a static, get-only `schema` property. This string references the table or collection this model represents. 

```swift
final class Galaxy: Model {
    // Name of the table or collection.
    static let schema = "galaxies"
}
```

When querying this model, data will be fetched from and stored to the schema named `"galaxies"`.

!!! tip
    The schema name is typically the class name pluralized and lowercased. 

## Identifier

All models must have an `id` property defined using the `@ID` property wrapper. This field uniquely identifies instances of your model.

```swift
final class Galaxy: Model {
    // Unique identifier for this Galaxy.
    @ID(key: .id)
    var id: UUID?
}
```

By default, the `@ID` property should use the special `.id` key which resolves to an appropriate key for the underlying database driver. For SQL this is `"id"` and for NoSQL it is `"_id"`. 

The `@ID` should also be of type `UUID`. This is the only identifier value currently supported by all database drivers. Fluent will automatically generate new UUID identifiers when models are created. 

### Custom

Fluent supports custom identifier keys and types using the `@ID(custom:)` overload. 

```swift
final class Galaxy: Model {
    // Unique identifier for this Galaxy.
    @ID(custom: "foo")
    var id: Int?
}
```

The above example uses an `@ID` with custom key `"foo"` and identifier type `Int`. This is compatible with SQL databases using auto-incrementing primary keys, but is not compatible with NoSQL. 

Custom `@ID`s allow the user to specify how the identifier should be generated using the `generatedBy` parameter.

```swift
@ID(custom: "foo", generatedBy: .user)
```

There are three cases:

|Generated By|Description|
|-|-|
|`.user`|`@ID` property is expected to be set before saving a new model.|
|`.random`|`@ID` value type must conform to `RandomGeneratable`.|
|`.database`|Database is expected to generate a value upon save.|

If the `generatedBy` parameter is omitted, Fluent will attempt to infer an appropriate case based on the `@ID` value type. For example, `Int` will default to `.database` generation unless otherwise specified.
